<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paddle Water Catching Visualiser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            cursor: crosshair;
            touch-action: none; /* Prevents default touch actions like scrolling */
            position: relative; /* Ensure canvas is in the stacking context */
            z-index: 5; /* Canvas on top of the image */
        }
        .info-panel, .controls-panel {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .panel-hidden-left {
            opacity: 0;
            transform: translateX(-120%); /* Hide to the left */
            pointer-events: none;
        }
        .panel-hidden-right {
            opacity: 0;
            transform: translateX(120%); /* Hide to the right */
            pointer-events: none;
        }
        #bgContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* This will contain the image */
        }
        #bgImage {
            position: absolute;
            pointer-events: none; /* Let events pass through to the canvas or container */
            z-index: 1;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center h-screen m-0 p-2 sm:p-4">

    <h1 class="text-xl sm:text-3xl font-bold text-white my-2 text-center">Paddle Water Catching Visualiser</h1>

    <div class="w-full max-w-5xl flex-grow flex flex-col items-center">
        <div class="relative w-full max-w-4xl aspect-video bg-gray-800 rounded-xl shadow-2xl overflow-hidden border-2 border-gray-700">
            <div id="bgContainer">
                <img id="bgImage" src="" alt="User uploaded background">
            </div>
            <canvas id="paddleCanvas"></canvas>
        </div>
    
        <div class="mt-4 flex flex-wrap justify-center items-center gap-2 sm:gap-4">
            <button id="anchorBtn" class="px-4 py-2 text-sm sm:px-6 sm:text-base bg-cyan-600 hover:bg-cyan-700 text-white font-semibold rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-75">
                Set Anchor
            </button>
            <button id="bgModeBtn" class="px-4 py-2 text-sm sm:px-6 sm:text-base bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                Control BG
            </button>
             <button id="resetBtn" class="px-4 py-2 text-sm sm:px-6 sm:text-base bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75">
                Reset
            </button>
            <button id="showInstructionsBtn" class="hidden px-4 py-2 text-sm sm:px-6 sm:text-base bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg shadow-md transition-all duration-200">
                Instructions
            </button>
        </div>
    </div>


    <div id="infoPanel" class="info-panel absolute top-4 left-4 bg-black bg-opacity-50 p-3 rounded-lg text-xs sm:text-sm text-gray-300 max-w-[180px] sm:max-w-xs z-10">
        <div class="flex justify-between items-center mb-2">
            <h2 class="text-base sm:text-lg font-bold text-white">Instructions</h2>
            <button id="hideInstructionsBtn" class="text-xs text-gray-400 hover:text-white">Hide</button>
        </div>
        <ul class="list-disc list-inside space-y-1">
            <li><strong class="text-cyan-400">Move:</strong> Left-click/1-finger drag.</li>
            <li><strong class="text-cyan-400">Rotate:</strong> Right-click/2-finger drag.</li>
            <li><strong class="text-cyan-400">Set Anchor:</strong> Use button, then click paddle.</li>
            <li><strong class="text-purple-400">Control BG:</strong> Toggle mode, then drag.</li>
        </ul>
    </div>

    <div id="controlsPanel" class="controls-panel panel-hidden-right absolute top-4 right-4 bg-black bg-opacity-50 p-3 rounded-lg text-xs sm:text-sm text-gray-300 max-w-[180px] sm:max-w-xs z-10">
        <h2 class="text-base sm:text-lg font-bold text-white mb-2">Background</h2>
        <input type="file" id="bgUpload" class="hidden" accept="image/*">
        <button id="uploadBtn" class="w-full px-4 py-2 text-sm bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg shadow-md transition-all duration-200">
            Upload Image
        </button>
        <div id="bgControls" class="hidden mt-4">
            <label for="bgScale" class="block mb-1">Scale:</label>
            <input type="range" id="bgScale" min="0.1" max="5" step="0.05" value="1" class="w-full">
        </div>
    </div>


    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('paddleCanvas');
        const ctx = canvas.getContext('2d');
        const anchorBtn = document.getElementById('anchorBtn');
        const bgModeBtn = document.getElementById('bgModeBtn');
        const resetBtn = document.getElementById('resetBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const bgUpload = document.getElementById('bgUpload');
        const bgContainer = document.getElementById('bgContainer');
        const bgImage = document.getElementById('bgImage');
        const controlsPanel = document.getElementById('controlsPanel');
        const bgControls = document.getElementById('bgControls');
        const bgScale = document.getElementById('bgScale');
        const infoPanel = document.getElementById('infoPanel');
        const hideInstructionsBtn = document.getElementById('hideInstructionsBtn');
        const showInstructionsBtn = document.getElementById('showInstructionsBtn');

        // --- State ---
        let isSettingAnchor = false;
        let isBgMode = false;
        let paddle = {};
        let waterLevel; 

        // Interaction states
        let isRotating = false;
        let isMoving = false;
        let isBgDragging = false;
        let dragStart = { x: 0, y: 0 };
        let initialPaddlePos = {};
        let currentPivot = null; 
        let initialDistances = { tip: 0, handle: 0 };
        
        // Background image state
        let bgImageState = { naturalWidth: 0, naturalHeight: 0, scale: 1, x: 0, y: 0 };
        let initialBgPos = { x: 0, y: 0 };


        // --- Initialization and Resizing ---
        function resizeCanvas() {
            const container = canvas.parentElement;
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            
            if (!container.clientWidth || !container.clientHeight) return;
            if (oldWidth === container.clientWidth && oldHeight === container.clientHeight) return;

            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            const scaleX = canvas.width / oldWidth;
            const scaleY = canvas.height / oldHeight;

            waterLevel = canvas.height * (2 / 3);
            if (bgImage.src) {
                updateImageTransform();
            }

            if (!paddle.handle || !oldWidth || !oldHeight) {
                init();
            } else {
                // BUG FIX: Intelligently rescale paddle to prevent distortion
                const centerX = (paddle.handle.x + paddle.tip.x) / 2;
                const centerY = (paddle.handle.y + paddle.tip.y) / 2;
                const angle = Math.atan2(paddle.tip.y - paddle.handle.y, paddle.tip.x - paddle.handle.x);

                const newCenterX = centerX * scaleX;
                const newCenterY = centerY * scaleY;
                const newLength = canvas.height * 0.6; // Keep length proportional to height

                paddle.length = newLength;
                const halfLength = newLength / 2;

                paddle.handle.x = newCenterX - Math.cos(angle) * halfLength;
                paddle.handle.y = newCenterY - Math.sin(angle) * halfLength;
                paddle.tip.x = newCenterX + Math.cos(angle) * halfLength;
                paddle.tip.y = newCenterY + Math.sin(angle) * halfLength;
                
                draw();
            }
        }

        function init() {
            waterLevel = canvas.height * (2 / 3);
            const paddleLength = canvas.height * 0.6; // Responsive paddle length
            const initialY = canvas.height / 3;

            paddle = {
                handle: { x: canvas.width / 2, y: initialY - paddleLength / 2 },
                tip: { x: canvas.width / 2, y: initialY + paddleLength / 2 },
                length: paddleLength,
                anchorRatio: null
            };
            isSettingAnchor = false;
            anchorBtn.textContent = 'Set Anchor';
            anchorBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            anchorBtn.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
            
            isBgMode = false;
            bgModeBtn.textContent = 'Control BG';
            bgModeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
            bgModeBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
            canvas.style.pointerEvents = 'auto';
            controlsPanel.classList.add('panel-hidden-right');


            // Reset background
            bgUpload.value = null; 
            bgImage.src = '';
            bgControls.classList.add('hidden');
            bgScale.value = 1;
            bgImageState = { naturalWidth: 0, naturalHeight: 0, scale: 1, x: 0, y: 0 };
            updateImageTransform();

            // Instructions Panel Logic
            hideInstructions(); // Start with instructions hidden

            draw();
        }

        // --- Drawing Functions ---
        function drawPaddle() {
            ctx.save();
            ctx.lineWidth = Math.max(4, canvas.width * 0.01); // Responsive line width
            ctx.lineCap = 'round';

            const bladeStartRatio = 0.6;
            const bladeStartPoint = {
                x: paddle.handle.x + (paddle.tip.x - paddle.handle.x) * bladeStartRatio,
                y: paddle.handle.y + (paddle.tip.y - paddle.handle.y) * bladeStartRatio
            };

            // Shaft
            ctx.strokeStyle = '#E2E8F0';
            ctx.beginPath();
            ctx.moveTo(paddle.handle.x, paddle.handle.y);
            ctx.lineTo(bladeStartPoint.x, bladeStartPoint.y);
            ctx.stroke();

            // Blade
            ctx.strokeStyle = '#3b82f6';
            ctx.beginPath();
            ctx.moveTo(bladeStartPoint.x, bladeStartPoint.y);
            ctx.lineTo(paddle.tip.x, paddle.tip.y);
            ctx.stroke();

            // Perpendicular Handle
            const shaftAngle = Math.atan2(paddle.tip.y - paddle.handle.y, paddle.tip.x - paddle.handle.x);
            const handleAngle = shaftAngle + Math.PI / 2;
            const handleHalfWidth = paddle.length * 0.08;
            const h1 = {
                x: paddle.handle.x + Math.cos(handleAngle) * handleHalfWidth,
                y: paddle.handle.y + Math.sin(handleAngle) * handleHalfWidth
            };
            const h2 = {
                x: paddle.handle.x - Math.cos(handleAngle) * handleHalfWidth,
                y: paddle.handle.y - Math.sin(handleAngle) * handleHalfWidth
            };
            ctx.strokeStyle = '#E2E8F0';
            ctx.lineWidth = Math.max(5, canvas.width * 0.015);
            ctx.beginPath();
            ctx.moveTo(h1.x, h1.y);
            ctx.lineTo(h2.x, h2.y);
            ctx.stroke();

            if (paddle.anchorRatio !== null) {
                const anchorX = paddle.handle.x + (paddle.tip.x - paddle.handle.x) * paddle.anchorRatio;
                const anchorY = paddle.handle.y + (paddle.tip.y - paddle.handle.y) * paddle.anchorRatio;
                ctx.fillStyle = '#6EE7B7';
                ctx.beginPath();
                ctx.arc(anchorX, anchorY, Math.max(4, canvas.width * 0.01), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawWater() {
            // Draw the main water surface line
            ctx.beginPath();
            ctx.moveTo(0, waterLevel);
            ctx.lineTo(canvas.width, waterLevel);
            ctx.strokeStyle = 'rgba(56, 189, 248, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            const bladeStartRatio = 0.6;
            const bladeStartPoint = {
                x: paddle.handle.x + (paddle.tip.x - paddle.handle.x) * bladeStartRatio,
                y: paddle.handle.y + (paddle.tip.y - paddle.handle.y) * bladeStartRatio
            };

            // Dynamic Max Depth Indicator
            const maxBladeDepth = paddle.length * 0.4;
            const maxDepthY = bladeStartPoint.y + maxBladeDepth;
            
            if (maxDepthY > waterLevel) {
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(250, 204, 21, 0.7)'; // Yellow
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.moveTo(0, maxDepthY);
                ctx.lineTo(canvas.width, maxDepthY);
                ctx.stroke();
                ctx.restore();
            }

            if (paddle.tip.y <= waterLevel || bladeStartPoint.y > paddle.tip.y) return;

            const entryPoint = lineIntersection(paddle.handle, paddle.tip, {x:0, y:waterLevel}, {x:canvas.width, y:waterLevel});
            if (!entryPoint) return;

            let submergedBladeTopPoint = (entryPoint.y < bladeStartPoint.y) ? bladeStartPoint : entryPoint;

            const rectTop = submergedBladeTopPoint.y;
            const rectBottom = paddle.tip.y;

            if (rectBottom <= rectTop) return;

            const intersection = submergedBladeTopPoint;

            const leftPolygon = [
                { x: 0, y: rectTop }, intersection, paddle.tip,
                { x: paddle.tip.x, y: rectBottom }, { x: 0, y: rectBottom }
            ];
            const rightPolygon = [
                { x: canvas.width, y: rectTop }, intersection, paddle.tip,
                { x: paddle.tip.x, y: rectBottom }, { x: canvas.width, y: rectBottom }
            ];

            ctx.fillStyle = 'rgba(168, 85, 247, 0.7)';
            ctx.beginPath();
            leftPolygon.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
            ctx.beginPath();
            rightPolygon.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();
        }

        function draw() {
            if (!paddle || !paddle.handle) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWater();
            drawPaddle();
        }

        // --- UI Panel Logic ---
        function hideInstructions() {
            infoPanel.classList.add('panel-hidden-left');
            showInstructionsBtn.classList.remove('hidden');
        }

        function showInstructions() {
            infoPanel.classList.remove('panel-hidden-left');
            showInstructionsBtn.classList.add('hidden');
        }


        // --- Event Handlers ---
        function handleMouseDown(e) {
            const pos = getMousePos(e);
            
            if (isBgMode) {
                isBgDragging = true;
                dragStart = pos;
                initialBgPos = { x: bgImageState.x, y: bgImageState.y };
                return;
            }

            if (isSettingAnchor) {
                const closestPoint = closestPointOnLine(paddle.handle, paddle.tip, pos);
                const distFromHandle = distance(paddle.handle, closestPoint);
                const totalLength = distance(paddle.handle, paddle.tip);
                paddle.anchorRatio = totalLength > 0 ? distFromHandle / totalLength : 0;
                
                isSettingAnchor = false;
                anchorBtn.textContent = 'Set Anchor';
                anchorBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                anchorBtn.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
                draw();
                return;
            }

            if (e.button === 0) { // Left-click for MOVING
                isMoving = true;
                dragStart = pos;
                initialPaddlePos = { handle: { ...paddle.handle }, tip: { ...paddle.tip } };
            } else if (e.button === 2) { // Right-click for ROTATING
                isRotating = true;
                if (paddle.anchorRatio !== null) {
                    currentPivot = {
                        x: paddle.handle.x + (paddle.tip.x - paddle.handle.x) * paddle.anchorRatio,
                        y: paddle.handle.y + (paddle.tip.y - paddle.handle.y) * paddle.anchorRatio
                    };
                } else {
                    currentPivot = { ...paddle.handle };
                }
                
                initialDistances = { 
                    tip: distance(currentPivot, paddle.tip), 
                    handle: distance(currentPivot, paddle.handle) 
                };
            }
        }

        function handleMouseMove(e) {
            const pos = getMousePos(e);
            const dx = pos.x - dragStart.x;
            const dy = pos.y - dragStart.y;

            if (isBgDragging) {
                bgImageState.x = initialBgPos.x + dx;
                bgImageState.y = initialBgPos.y + dy;
                updateImageTransform();
                return;
            }

            if (isMoving) {
                paddle.handle.x = initialPaddlePos.handle.x + dx;
                paddle.handle.y = initialPaddlePos.handle.y + dy;
                paddle.tip.x = initialPaddlePos.tip.x + dx;
                paddle.tip.y = initialPaddlePos.tip.y + dy;
                draw();
            }

            if (isRotating) {
                if (!currentPivot) return;
                const angle = Math.atan2(pos.y - currentPivot.y, pos.x - currentPivot.x);
                
                paddle.tip.x = currentPivot.x + Math.cos(angle) * initialDistances.tip;
                paddle.tip.y = currentPivot.y + Math.sin(angle) * initialDistances.tip;

                paddle.handle.x = currentPivot.x - Math.cos(angle) * initialDistances.handle;
                paddle.handle.y = currentPivot.y - Math.sin(angle) * initialDistances.handle;
                draw();
            }
        }

        function handleMouseUp() {
            isRotating = false;
            isMoving = false;
            isBgDragging = false;
            currentPivot = null; 
        }

        // --- Touch Handlers ---
        function handleTouchStart(e) {
            e.preventDefault();
            const touches = e.touches;
            if (isBgMode) {
                if (touches.length === 1) {
                    isBgDragging = true;
                    dragStart = getTouchPos(touches[0]);
                    initialBgPos = { x: bgImageState.x, y: bgImageState.y };
                }
                return;
            }

            if (touches.length === 1) { // Single finger for MOVING
                isMoving = true;
                dragStart = getTouchPos(touches[0]);
                initialPaddlePos = { handle: { ...paddle.handle }, tip: { ...paddle.tip } };
            } else if (touches.length === 2) { // Two fingers for ROTATING
                isRotating = true;
                if (paddle.anchorRatio !== null) {
                    currentPivot = {
                        x: paddle.handle.x + (paddle.tip.x - paddle.handle.x) * paddle.anchorRatio,
                        y: paddle.handle.y + (paddle.tip.y - paddle.handle.y) * paddle.anchorRatio
                    };
                } else {
                    currentPivot = { ...paddle.handle };
                }
                initialDistances = { tip: distance(currentPivot, paddle.tip), handle: distance(currentPivot, paddle.handle) };
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touches = e.touches;
            if (isBgDragging && touches.length === 1) {
                const pos = getTouchPos(touches[0]);
                const dx = pos.x - dragStart.x;
                const dy = pos.y - dragStart.y;
                bgImageState.x = initialBgPos.x + dx;
                bgImageState.y = initialBgPos.y + dy;
                updateImageTransform();
                return;
            }

            if (isMoving && touches.length === 1) {
                const pos = getTouchPos(touches[0]);
                const dx = pos.x - dragStart.x;
                const dy = pos.y - dragStart.y;
                paddle.handle.x = initialPaddlePos.handle.x + dx;
                paddle.handle.y = initialPaddlePos.handle.y + dy;
                paddle.tip.x = initialPaddlePos.tip.x + dx;
                paddle.tip.y = initialPaddlePos.tip.y + dy;
                draw();
            } else if (isRotating && touches.length === 2) {
                if (!currentPivot) return;
                const pos = getMidpoint(touches[0], touches[1]);
                const angle = Math.atan2(pos.y - currentPivot.y, pos.x - currentPivot.x);
                
                paddle.tip.x = currentPivot.x + Math.cos(angle) * initialDistances.tip;
                paddle.tip.y = currentPivot.y + Math.sin(angle) * initialDistances.tip;

                paddle.handle.x = currentPivot.x - Math.cos(angle) * initialDistances.handle;
                paddle.handle.y = currentPivot.y - Math.sin(angle) * initialDistances.handle;
                draw();
            }
        }

        function handleTouchEnd() {
            isRotating = false;
            isMoving = false;
            isBgDragging = false;
            currentPivot = null; 
        }

        // --- Background Image Handlers ---
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    bgImage.src = event.target.result;
                    bgImage.onload = () => {
                        bgImageState.naturalWidth = bgImage.naturalWidth;
                        bgImageState.naturalHeight = bgImage.naturalHeight;
                        bgControls.classList.remove('hidden');
                        bgScale.value = 1;
                        bgImageState.scale = 1;
                        bgImageState.x = (bgContainer.clientWidth - bgImage.naturalWidth) / 2;
                        bgImageState.y = (bgContainer.clientHeight - bgImage.naturalHeight) / 2;
                        updateImageTransform();
                    };
                };
                reader.readAsDataURL(file);
            }
        }

        function handleImageScale(e) {
            bgImageState.scale = parseFloat(e.target.value);
            updateImageTransform();
        }

        function updateImageTransform() {
            const imgWidth = bgImageState.naturalWidth * bgImageState.scale;
            const imgHeight = bgImageState.naturalHeight * bgImageState.scale;
            bgImage.style.width = `${imgWidth}px`;
            bgImage.style.height = `${imgHeight}px`;
            bgImage.style.left = `${bgImageState.x}px`;
            bgImage.style.top = `${bgImageState.y}px`;
        }

        // --- Utility Functions ---
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        }
        function getMidpoint(t1, t2) {
            const p1 = getTouchPos(t1);
            const p2 = getTouchPos(t2);
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }
        function distance(p1, p2) { return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)); }
        function lineIntersection(p1, p2, p3, p4) {
            const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (den === 0) return null;
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
            }
            return null;
        }
        function closestPointOnLine(p1, p2, p) {
            const l2 = Math.pow(distance(p1, p2), 2);
            if (l2 === 0) return p1;
            const t = Math.max(0, Math.min(1, ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / l2));
            return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
        }

        // --- Event Listener Setup ---
        const containerForMouse = canvas.parentElement;
        containerForMouse.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        containerForMouse.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch Listeners
        containerForMouse.addEventListener('touchstart', handleTouchStart, { passive: false });
        window.addEventListener('touchmove', handleTouchMove, { passive: false });
        window.addEventListener('touchend', handleTouchEnd);
        window.addEventListener('touchcancel', handleTouchEnd);


        anchorBtn.addEventListener('click', () => {
            isSettingAnchor = !isSettingAnchor;
            anchorBtn.textContent = isSettingAnchor ? 'Cancel Anchor' : 'Set Anchor';
            anchorBtn.classList.toggle('bg-yellow-500', isSettingAnchor);
            anchorBtn.classList.toggle('hover:bg-yellow-600', isSettingAnchor);
            anchorBtn.classList.toggle('bg-cyan-600', !isSettingAnchor);
            anchorBtn.classList.toggle('hover:bg-cyan-700', !isSettingAnchor);
        });
        
        bgModeBtn.addEventListener('click', () => {
            isBgMode = !isBgMode;
            bgModeBtn.textContent = isBgMode ? 'Control Paddle' : 'Control BG';
            bgModeBtn.classList.toggle('bg-green-500', isBgMode);
            bgModeBtn.classList.toggle('hover:bg-green-600', isBgMode);
            bgModeBtn.classList.toggle('bg-purple-600', !isBgMode);
            bgModeBtn.classList.toggle('hover:bg-purple-700', !isBgMode);
            
            canvas.style.pointerEvents = isBgMode ? 'none' : 'auto';
            controlsPanel.classList.toggle('panel-hidden-right', !isBgMode);
        });

        resetBtn.addEventListener('click', init);
        uploadBtn.addEventListener('click', () => bgUpload.click());
        bgUpload.addEventListener('change', handleImageUpload);
        bgScale.addEventListener('input', handleImageScale);
        hideInstructionsBtn.addEventListener('click', hideInstructions);
        showInstructionsBtn.addEventListener('click', showInstructions);

        // --- Start ---
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);

    </script>

    <a href="https://buymeacoffee.com/jysportech" target="_blank" 
    rel="noopener noreferrer" id="bmcButton" style="
        position: fixed;
        left: 20px;
        bottom: 20px;
        z-index: 50;
        background: rgba(0,0,0,0.7);
        border-radius: 12px;
        padding: 8px;
        display: flex;
        align-items: center;
        box-shadow: 0 2px 12px rgba(0,0,0,0.3);
    "    title="Buy me a coffee!"
>
    <img 
        src="buymeacoffee_yellow.jpg" 
        alt="Buy Me a Coffee" 
        style="height: 40px; width: auto;"
    >
</a>
</body>
</html>
